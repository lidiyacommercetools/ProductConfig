
%Numerical representation of an atom 
assignment(X,Y):- output(X,Q), literal_tuple(Q,Y).

%Pick any rule type
any_rule(V,P):- 1{rule(disjunction(V),normal(P)); rule(choice(V),normal(P)); rule(choice(V),sum(P)); rule(disjunction(V),sum(P)) }1, atom_tuple(V), literal_tuple(P).
any_choice_rule(V,P):- 1{rule(choice(V),normal(P)); rule(choice(V),sum(P))}1, atom_tuple(V), literal_tuple(P).
any_disjunction_rule(V,P):- 1{rule(disjunction(V),normal(P)); rule(disjunction(V),sum(P)) }1, atom_tuple(V), literal_tuple(P).

%Numertical representation of the atom to be explained
why_assignment(X,D):- why(X),answer(X),assignment(X,D).


% Explanation for membership


% Atom X depends on atom Y in rule P (  X:- Y  )
depends(X,Y,P):- why_assignment(X,N), answer(Y), assignment(Y,Q), literal_tuple(P,Q),  any_disjunction_rule(V,P), atom_tuple(V,N).


% Atom X depends on the negetation of atom Y in rule C ( X :- not Y.  )
depends_neg(X,Y,C):- why_assignment(X,D), not answer(Y), assignment(Y,B), literal_tuple(A,-B), 
any_disjunction_rule(C,A), atom_tuple(C,D).


% Atom X was chosen in choice rule A
choice_rule(X,A):-  why_assignment(X,V), any_choice_rule(A,_), atom_tuple(A,V), not original_fact(X).

% Atom is a fact
original_fact(X):- why(X), answer(X), fact(X).


% Explanation for lack of membership

% Atom does not occur in a rule head
not_mentioned(X):- why_not(X), not output(X,_), not original_fact(X).

%Part of a choice rule and not chosen
not_chosen(X,A):- why_not(X), 1{not answer(X);empty_set}, assignment(X,C), atom_tuple(A,C),  any_choice_rule(A,_), not constraint_issue'(X,_).


%Body of the rule was not satisfied
head_lit(X,A):- any_disjunction_rule(A,_), atom_tuple(A,C), assignment(X,C).

problem(Y,A):- any_disjunction_rule(A,B), literal_tuple(B,D), assignment(Y,D), not answer(Y).

problem_neg(Y,A):- any_disjunction_rule(A,B), literal_tuple(B,-D), assignment(Y,D), answer(Y).
not_satisfied(X,Y,A):- head_lit(X,A), {problem(Y,A); problem_neg(Y,A)}=1, not answer(X), why_not(X), output(Y,_).


%Constraint
constraint(P):- any_rule(V,P), not atom_tuple(V,_).


constraint_sat(X,A):- constraint(A), rule(_,normal(A)), literal_tuple(A,-B), assignment(X,B), answer(X).
constraint_sat(X,A):- constraint(A),rule(_,normal(A)), literal_tuple(A,B), assignment(X,B), not answer(X).
constraint_sat(X,A):- constraint(A),rule(_,sum(A)), literal_tuple(A,-B), assignment(X,B), answer(X).
constraint_sat(X,A):- constraint(A),rule(_,sum(A)), literal_tuple(A,B), assignment(X,B), not answer(X).



% Will only print non-facts due to grounding prior to reification
constraint_issue(P):- not constraint_sat(X,P), assignment(X,B), literal_tuple(P,B), any_rule(_,P), not original_fact(X).


constraint_issue'(X,P):- constraint_issue(P), any_rule(_,P), literal_tuple(P,Y), assignment(X,Y), why_not(X).

reasons_for_constraint(X,P):- constraint_issue'(_,P), literal_tuple(P,S), assignment(X,S), not why_not(X).
reasons_for_constraint(X):- reasons_for_constraint(X,P).

#show depends/3.
#show original_fact/1.
#show depends_neg/3.
#show choice_rule/2.
#show not_mentioned/1.
#show not_chosen/2.
#show not_satisfied/3.
%#show assignment/2.
%#show constraint_issue/1.
#show reasons_for_constraint/1.
