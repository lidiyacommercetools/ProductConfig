
%Numerical representation of an atom 
assignment(X,Y):- output(X,Q), literal_tuple(Q,Y).

%Numertical representation of the atom to be explained
why_assignment(X,D):- why(X),answer(X),assignment(X,D).


%Pick any rule type
any_rule(V,P):- 1{rule(disjunction(V),normal(P)); rule(choice(V),normal(P)); rule(choice(V),sum(P)); rule(disjunction(V),sum(P)) }1,
atom_tuple(V), literal_tuple(P).
any_choice_rule(V,P):- 1{rule(choice(V),normal(P)); rule(choice(V),sum(P))}1, atom_tuple(V), literal_tuple(P).
any_disjunction_rule(V,P):- 1{rule(disjunction(V),normal(P)); rule(disjunction(V),sum(P)) }1, atom_tuple(V), literal_tuple(P).



% Explanation for membership


% Atom X depends on atom Y in rule P (  X:- Y  )

rule_unsatisfied(P):- any_rule(V,P), literal_tuple(P,W), assignment(X,W), not answer(X).
rule_unsatisfied(P):- any_rule(V,P), literal_tuple(P,-W), assignment(X,W), answer(X).

depends(X,Y,P):- why_assignment(X,N), answer(Y), assignment(Y,Q), literal_tuple(P,Q),  
any_disjunction_rule(V,P), atom_tuple(V,N), not rule_unsatisfied(P).



% Atom X depends on the negation of atom Y in rule C ( X :- not Y.  )
depends_neg(X,Y,A):- why_assignment(X,D), not answer(Y), assignment(Y,B), literal_tuple(A,-B), 
any_disjunction_rule(C,A), atom_tuple(C,D), not rule_unsatisfied(A).



% Atom X was chosen in choice rule A
choice_rule(X,A):-  why_assignment(X,V), any_choice_rule(A,B), atom_tuple(A,V), not original_fact(X), not literal_tuple(B,_).
in_choice_rule(V,A):- choice_rule(X,A), atom_tuple(A,Y), assignment(V,Y), V!=X.
why_not(X):- not why(X), in_choice_rule(X,A).



% Atom is a fact
original_fact(X):- why(X), answer(X), fact(X).



% Rule was satisfied and atom was chosen in a choice rule {a}:- b,c.

head_choice(X,A):- rule(choice(A), normal(B)), why(X), atom_tuple(A,C), assignment(X,C).
bodysat_chosen(X,A,B):- not original_fact(X), head_choice(X,A), rule(choice(A), normal(B)), not rule_unsatisfied(B), literal_tuple(B,_).
body(Y,B):- bodysat_chosen(X,A,B), why(X), X!=Y, literal_tuple(B,Z), assignment(Y,Z).






% Explanation for lack of membership

% Atom does not occur in a rule head
not_mentioned(X):- why_not(X), not output(X,_), not original_fact(X).

%Part of a choice rule and not chosen
%not_chosen(X,A):- why_not(X), 1{not answer(X);empty_set}, assignment(X,C), atom_tuple(A,C),  any_choice_rule(A,_), not constraint_issue'(X,_).


%Body of the rule was not satisfied
head_lit(X,A):- any_disjunction_rule(A,_), atom_tuple(A,C), assignment(X,C).

rule_unsatisfied(X,P):- head_lit(X,A), any_disjunction_rule(A,P), rule_unsatisfied(P), why_not(X).
rule_issue(Y,P):- rule_unsatisfied(X,P), literal_tuple(P,Q), assignment(Y,Q), not answer(Y).
rule_issue_neg(Y,P):- rule_unsatisfied(X,P), literal_tuple(P,-Q), assignment(Y,Q), answer(Y).




%Constraint and contains the why_not atom
constraint(P,X):- any_disjunction_rule(V,P), not atom_tuple(V,_), literal_tuple(P,A), 
assignment(X,A), why_not(X). 

% A constraint is satisfied and therefore is not used
constraint_sat(X,A):- constraint(A,Y), why_not(Y), literal_tuple(A,B), assignment(X,B), not answer(X), X!=Y.
constraint_sat(X,A):- constraint(A,Y), why_not(Y), literal_tuple(A,-B), assignment(X,B), answer(X), X!=Y.


% A constraint is not satisfied and includes the atom in question
constraint_why(X,A):- not constraint_sat(_,A), constraint(A,X).


{constraint_chosen(X,P): constraint_why(X,P)}=1 :- why_not(X).
:- constraint_chosen(X,A), constraint_chosen(X',A), X!=X'.


% The atoms in the constraint that cause the why_not atom to be missing from the answer empty_set


reasons_for_constraint(Y,X):- constraint_chosen(X,A), literal_tuple(A,B), assignment(Y,B), not why_not(Y).
:- constraint_why(X,A), not reasons_for_constraint(_,X).
:- why_not(X), not head_lit(X,_), not reasons_for_constraint(_,X).
