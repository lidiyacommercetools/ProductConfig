%Numerical representation of an atom 
assignment(X,Y):- output(X,Q), literal_tuple(Q,Y).

%Numertical representation of the atom to be explained
why_assignment(X,D):- why(X),answer(X),assignment(X,D).


%Pick any rule type
any_rule(V,P):- 1{rule(disjunction(V),normal(P)); rule(choice(V),normal(P)); rule(choice(V),sum(P)); rule(disjunction(V),sum(P)) }1,
atom_tuple(V), literal_tuple(P).
any_choice_rule(V,P):- 1{rule(choice(V),normal(P)); rule(choice(V),sum(P))}1, atom_tuple(V), literal_tuple(P).
any_disjunction_rule(V,P):- 1{rule(disjunction(V),normal(P)); rule(disjunction(V),sum(P)) }1, atom_tuple(V), literal_tuple(P).

% Explanation for membership


% Atom X depends on atom Y in rule P (  X:- Y  )

rule_unsatisfied(P):- any_rule(V,P), literal_tuple(P,W), assignment(X,W), not answer(X).
rule_unsatisfied(P):- any_rule(V,P), literal_tuple(P,-W), assignment(X,W), answer(X).

depends(X,Y,P):- why_assignment(X,N), answer(Y), assignment(Y,Q), literal_tuple(P,Q),  
any_disjunction_rule(V,P), atom_tuple(V,N), not rule_unsatisfied(P).



% Atom X depends on the negation of atom Y in rule C ( X :- not Y.  )
depends_neg(X,Y,A):- why_assignment(X,D), not answer(Y), assignment(Y,B), literal_tuple(A,-B), 
any_disjunction_rule(C,A), atom_tuple(C,D), not rule_unsatisfied(A).


% Atom is a fact
original_fact(X):- why(X), answer(X), external(Z,_), literal_tuple(Y,Z), output(X,Y).

% Explanation for lack of membership

% Atom does not occur in a rule head
not_mentioned(X):- why_not(X), not output(X,_), not original_fact(X).


%Body of the rule was not satisfied
head_lit(X,A):- why_not(X), any_disjunction_rule(A,_), atom_tuple(A,C), assignment(X,C).
rule_unsatisfied(P):- any_rule(V,P), literal_tuple(P,W), assignment(X,W), not answer(X).
rule_unsatisfied(P):- any_rule(V,P), literal_tuple(P,-W), assignment(X,W), answer(X).
rule_unsatisfied(X,P):- head_lit(X,A), any_disjunction_rule(A,P), rule_unsatisfied(P), why_not(X).
rule_issue(Y,P):- rule_unsatisfied(X,P), literal_tuple(P,Q), assignment(Y,Q), not answer(Y).
rule_issue_neg(Y,P):- rule_unsatisfied(X,P), literal_tuple(P,-Q), assignment(Y,Q), answer(Y).


% Constraint issue  

constraint(P,V):- rule(disjunction(P),normal(V)), not atom_tuple(P,_), literal_tuple(V,Z), 
literal_tuple(Q,Z), output(_,Q).


%Constraint and contains the why_not atom
constraint(P,V,Y):- constraint(P,V), literal_tuple(V,Z), assignment(Y,Z), why_not(Y).

% A constraint is satisfied and therefore is not used
constraint_sat(X,V):- constraint(P,V,Y), literal_tuple(V,B), assignment(X,B), not answer(X), X!=Y.
constraint_sat(X,V):- constraint(P,V,Y), literal_tuple(V,-B), assignment(X,B), answer(X), X!=Y.


% A constraint is not satisfied and includes the atom in question
constraint_why(Y,V):- not constraint_sat(_,V), constraint(P,V,Y).
{constraint_chosen(X,P): constraint_why(X,P)}=1 :- constraint(_,_,X).

%:- constraint_chosen(X,A), constraint_chosen(X',A), X!=X'.


% The atoms in the constraint that cause the why_not atom to be missing from the answer


reasons_for_constraint(Y,X):- constraint_chosen(X,A), literal_tuple(A,B), assignment(Y,B), not why_not(Y).
%:- constraint_why(X,A), not reasons_for_constraint(_,X).
%:- why_not(X), not head_lit(X,_), not reasons_for_constraint(_,X).
